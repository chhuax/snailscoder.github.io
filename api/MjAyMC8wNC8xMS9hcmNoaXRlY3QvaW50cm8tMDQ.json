{"title":"高并发系统：池化技术-JDK线程池","date":"2020-04-11T22:39:25.000Z","date_formatted":{"ll":"2020年4月11日","L":"2020/04/11","MM-DD":"04-11"},"thumbnail":"https://blogimg-1254014761.cos.ap-beijing.myqcloud.com/2020/04/12/pexelsphoto1040161.jpeg","link":"2020/04/11/architect/intro-04","comments":true,"tags":["Java","架构","高并发"],"categories":["架构"],"updated":"2020-04-12T03:17:10.055Z","content":"<p>JDK 实现的这个线程池优先把任务放入队列暂存起来，而不是创建更多的线程，它比较适用于执行 CPU 密集型的任务，也就是需要执行大量 CPU 运算的任务。这是为什么呢？因为执行 CPU 密集型的任务时 CPU 比较繁忙，因此只需要创建和 CPU 核数相当的线程就好了，多了反而会造成线程上下文切换，降低任务执行效率。所以当前线程数超过核心线程数时，线程池不会增加线程，而是放在队列里等待核心线程空闲下来。</p>\n<p>一般核心线程数与CPU核数一致，计算公式：<br><code>线程数目 = CPU核数 * CPU 利用率 * (1 + 等待时间 / CPU计算时间)</code></p>\n<h4 id=\"jdk线程池核心参数\">JDK线程池核心参数<a href=\"#jdk线程池核心参数\" title=\"JDK线程池核心参数\"></a></h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;java.util.concurrent.ThreadPoolExecutor</span><br><span class=\"line\">public ThreadPoolExecutor(int corePoolSize,</span><br><span class=\"line\">                              int maximumPoolSize,</span><br><span class=\"line\">                              long keepAliveTime,</span><br><span class=\"line\">                              TimeUnit unit,</span><br><span class=\"line\">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class=\"line\">                              ThreadFactory threadFactory,</span><br><span class=\"line\">                              RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure><ul><li><strong>corePoolSize:</strong>线程池中的核心线程数,即使没有任务执行的时候,他们也是存在的.(不考虑配置了参数:allowCoreThreadTimeOut,allowCoreThreadTimeOut通过字面意思也能知道,就是是否允许核心线程超时,一般情况下不需要设置,本文不考虑)</li><li><strong>maximumPoolSize:</strong>线程池中的允许存在的最大线程数</li><li><strong>keepAliveTime:</strong>当线程池中的线程超过核心线程数的时候,这部分多余的空闲线程等待执行新任务的超时时间.例如:核心线程数为1 ,最大线程数为5,当前运行线程为4,keepAliveTime为60s,那么4-1=3个线程在空闲状态下等待60s 后还没有新任务到来,就会被销毁了.</li><li><strong>unit:</strong>keepAliveTime 的时间单位</li><li><strong>workQueue:</strong> 线程队列,如果当前时间核心线程都在运行,又来了一个新任务,那么这个新任务就会被放进这个线程队列中,等待执行.</li><li><strong>threadFactory:</strong> 线程池创建线程的工厂类.</li><li>handler: 如果线程队列满了同事执行线程数也达到了maximumPoolSize,如果此时再来新的线程,将执行什么 handler 来处理这个线程. handler的默认提供的类型有:<ul><li>AbortPolicy: 抛出RejectedExecutionException异常</li><li>DiscardPolicy: 什么都不做.</li><li>DiscardOldestPolicy: 将线程队列中的最老的任务抛弃掉,换区一个空间执行当前的任务.</li><li>CallerRunsPolicy: 使用当前的线程(比如 main)来执行这个线程.</li></ul></li></ul><h4 id=\"jdk线程创建回收策略\">JDK线程创建回收策略<a href=\"#jdk线程创建回收策略\" title=\"JDK线程创建回收策略\"></a></h4><ol><li><strong>&lt;corePoolSize:</strong>如果新加入一个运行的任务,当前运行的线程小于corePoolSize,这时候会在线程池中新建一个线程用于执行这个新的任务.</li><li><strong>&gt;corePoolSize,队列不满:</strong>如果新加入一个运行的任务,当前运行的线程大于等于corePoolSize,这个时候就需要将这个新的任务加入到线程队列workQueue中,一旦线程中的线程执行完成了一个任务,就会马上从队列中去一个任务来执行.</li><li><strong>&gt;corePoolSize,&lt;maximumPoolSize:</strong>如果队列也满了,怎么办呢? 如果maximumPoolSize大于corePoolSize,就会新建线程来处理这个新的任务,直到总运行线程数达到maximumPoolSize.</li><li><strong>&gt;maximumPoolSize:</strong>如果总运行线程数达到了maximumPoolSize,还来了新的任务怎么办呢?就需要执行上面所说的拒绝策略了handler了,按照配置的策略进行处理,默认不配置的情况下,使用的是AbortPolicy.</li><li><strong>keepAliveTime:</strong>超过corePoolSize的线程，在空闲时间超过keepAliveTime时会被释放</li><li><strong>allowCoreThreadTimeOut:</strong>在配置了allowCoreThreadTimeOut时，corePoolSize线程在空闲时也会释放，一般不配置。</li></ol>","prev":{"title":"高并发系统：池化技术-数据库连接池","link":"2020/04/11/architect/db-01"},"next":{"title":"高并发系统：系统可用性的度量","link":"2020/04/11/architect/intro-03"},"plink":"https://snailscoder.com/2020/04/11/architect/intro-04/","reward":true,"copyright":{"link":"<a href=\"https://snailscoder.com/2020/04/11/architect/intro-04/\" title=\"高并发系统：池化技术-JDK线程池\">https://snailscoder.com/2020/04/11/architect/intro-04/</a>","license":"自由转载-非商用-禁止演绎-保持署名(<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}