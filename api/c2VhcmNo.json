[{"title":"高并发系统：数据库优化-分库分表","date":"2020-04-12T12:59:25.000Z","date_formatted":{"ll":"2020年4月12日","L":"2020/04/12","MM-DD":"04-12"},"updated":"2020-04-12T06:01:19.824Z","content":"在 4 核 8G 的云服务器上对 MySQL 5.7 做 Benchmark，大概可以支撑 500TPS 和 10000QPS，如果出现写并发量大时，该如何解决？出现数据库容量瓶颈时如何解决？单纯从数据库层面考虑一般采用垂直拆分和水平拆分来解决。数据库分库分表的方式有两种：一种是垂直拆分，另一种是水平拆分。这两种方式，在我看来，掌握拆分方式是关键，理解拆分原理是内核。所以你在学习时，最好可以结合自身业务来思考。\n拆分方式1、垂直拆分垂直拆分，顾名思义就是对数据库竖着拆分，也就是将数据库的表拆分到多个不同的数据库中。垂直拆分的原则一般是按照业务类型来拆分，核心思想是专库专用，将业务耦合度比较高的表拆分到单独的库中。举个形象的例子，就是在整理衣服的时候，将羽绒服、毛衣、T 恤分别放在不同的格子里。这样可以解决我在开篇提到的第三个问题：把不同的业务的数据分拆到不同的数据库节点上，这样一旦数据库发生故障时只会影响到某一个模块的功能，不会影响到整体功能，从而实现了数据层面的故障隔离。现在大多数公司都采用微服务架构，一般方案为按服务拆库，各服务不进行跨库读写数据。\n优点：各业务库独立，可以按业务重要性来区别对待，优先保障核心业务库。缺点：不能解决某一个业务模块的数据大量膨胀的问题\n2、水平拆分和垂直拆分的关注点不同，垂直拆分的关注点在于业务相关性，而水平拆分指的是将单一数据表按照某一种规则拆分到多个数据库和多个数据表中，关注点在数据的特点。一般按业务类型分为两种拆分方式：\n字段哈希值拆分这种拆分规则比较适用于实体表，数据相对独立，无明显时间概念等的数据，比如说用户表，可以先对用户 ID 做哈希（哈希的目的是将 ID 尽量打散）比如拆分成16个库，每库64张表。先对库数量16取余，决定划分到哪个库，后对库中表数量64取余，决定在哪张表。\n字段区间拆分比较常用的是时间字段，比如用户订单等按照下单时间来拆分表，用户查询订单时必须指定查询时间段。该例子不一定是最优方案哈，会存在热点问题，比如双十一一天内订单量超大就会存在问题。\n分库分表引入的问题分库分表引入的一个最大的问题就是引入了分库分表键，也叫做分区键，也就是我们对数据库做分库分表所依据的字段。\n一旦分区后，查询条件中必须带有分区键查询，明确要查询的数据在哪个区才有效，否则会带来更严重的性能问题。现阶段如何解决跨区查询问题呢，本人总结方式如下：1、先查后整合    一般是把两个表的数据取出后在业务代码里面做筛选，复杂是有一些，不过是可以实现的。2、数据冗余    如用户表按用户ID拆分，但需要按用户昵称查询用户的情况。    可以冗余一份用户昵称与用户ID量字段的表，先从该表中按昵称查询ID，再进行ID精准查询。当然该表也可以进行分区。3、借助三方中间件    涉及一些复杂的查询搜索功能，可以借助ElasticSearch等中间件，来进行搜索优化。\n有很多人并没有真正从根本上搞懂为什么要拆分，拆分后会带来哪些问题，只是一味地学习大厂现有的拆分方法，从而导致问题频出。所以，你在使用一个方案解决一个问题的时候一定要弄清楚原理，搞清楚这个方案会带来什么问题，要如何来解决，要知其然也知其所以然，这样才能在解决问题的同时避免踩坑。","plink":"https://snailscoder.com/2020/04/12/architect/108/"},{"title":"高并发系统：数据库优化-读写分离","date":"2020-04-12T10:49:25.000Z","date_formatted":{"ll":"2020年4月12日","L":"2020/04/12","MM-DD":"04-12"},"updated":"2020-04-12T04:21:17.229Z","content":"依据一些云厂商的 Benchmark 的结果，在 4 核 8G 的机器上运行 MySQL 5.7 时，大概可以支撑 500 的 TPS 和 10000 的 QPS。大部分系统的访问模型是读多写少，读写请求量的差距可能达到几个数量级。当单机MySQL达不到高并发读请求时的处理方案:主从读写分离\n主从读写的两个技术关键点一、主从复制MySQL 的主从复制是依赖于 binlog 的,主从复制就是将 binlog 中的数据从主库传输到从库上。具体过程：\n从库在连接到主节点时会创建一个 IO 线程，用以请求主库更新的 binlog，并且把接收到的 binlog 信息写入一个叫做 relay log 的日志文件中而主库也会创建一个 log dump 线程来发送 binlog 给从库；从库还会创建一个 SQL 线程读取 relay log 中的内容，并且在从库中做回放，最终实现主从的一致性。这是一种比较常见的主从复制方式。主从复制存在的问题数据延时问题为了不影响主库的性能，主从同步为异步过程。不能保障从库无延时同步。主从的一致性和写入性能的权衡如果你要保证所有从节点都写入成功，那么写入性能一定会受影响；如果你只写入主节点就返回成功，那么从节点就有可能出现数据同步失败的情况，从而造成主从不一致，而在互联网的项目中，我们一般会优先考虑性能而不是数据的强一致性。不能无限制增加从库数量增加从库主库会创建log dump线程，消耗主库性能，一般一个主库最多挂 3～5 个从库主从数据延时解决方案参考\n1. 数据冗余    异步消息传输时，不仅仅发送ID，而是发送全量信息，避免从库再次查询.    缺点:可能造成单条消息比较大，从而增加了消息发送的带宽和时间。2. 使用缓存    同步写数据库的同时,将数据写入缓存:如Redis，从Redis中读取。    缺点:更适合新增数据，更新数据需要考虑数据不一致问题\n注意：需要做好从库延时时间的监控，延时过大需要告警通知。正常的时间是在毫秒级别，一旦落后的时间达到了秒级别就需要告警了。\n\n二、程序访问一主多从，读写分离，存在多个数据库节点，程序需要选择性的连接，增加了访问的复杂度。为了降低实现的复杂度，业界涌现了很多数据库中间件来解决数据库的访问问题，这些中间件可以分为两类。\n1. 内嵌组件以淘宝的 TDDL为代表，以代码形式内嵌运行在应用程序内部，你可以把它看成是一种数据源的代理，它的配置管理着多个数据源，每个数据源对应一个数据库，可能是主库，可能是从库。当有一个数据库请求时，中间件将 SQL 语句发给某一个指定的数据源来处理，然后将处理结果返回。优点：简单易用，没有多余的部署成本缺点：缺乏多语言的支持，升级比较困难\n2. 增加代理层单独部署的代理层方案，中间件部署在独立的服务器上，业务代码如同在使用单一数据库一样使用它，实际上它内部管理着很多的数据源，当有数据库请求时，它会对 SQL 语句做必要的改写，然后发往指定的数据源。市面很多成熟中间件，具体可参考：分布式数据库中间件TDDL、Amoeba、Cobar、MyCAT架构比较\n优点：    * 使用标准的 MySQL 通信协议，所以可以很好地支持多语言    * 独立部署，维护升级方便缺点：    * 增加代理层，SQL多跨一层网络，有性能损耗    * 代理层专人维护成本增加\n注意：在使用任何中间件的时候一定要保证对于中间件有足够深入的了解，否则一旦出了问题没法快速地解决就悲剧了。\n\n名词解释QPS：每秒查询数，是针对读请求的TPS：每秒执行事务数，倾向于写请求binlog:记录 MySQL 上的所有变化并以二进制形式保存在磁盘上二进制日志文件扩展Redis主从复制原理总结","thumbnail":"https://blogimg-1254014761.cos.ap-beijing.myqcloud.com/2020/04/12/fenli.png","plink":"https://snailscoder.com/2020/04/12/architect/107/"},{"title":"高并发系统：池化技术-Tomcat、Undertow连接池","date":"2020-04-11T23:49:25.000Z","date_formatted":{"ll":"2020年4月11日","L":"2020/04/11","MM-DD":"04-11"},"updated":"2020-04-12T03:16:53.332Z","content":"Tomcat配置核心参数:max-threads:该线程池可以容纳的最大线程数。默认值：200server.tomcat.max-threads=1000max-connections:接受和处理的最大连接数server.tomcat.max-connections=20000min-SpareThreads:Tomcat应该始终打开的最小不活跃线程数。默认值：25。server.tomcat.min-SpareThreads=20acceptCount:可以放到处理队列中的请求数server.tomcat.acceptCount=700connectionTimeout 连接超时server.tomcat.connectionTimeout=1000\nUndertow配置核心参数io-threads:设置IO线程数, 它主要执行非阻塞的任务,它们会负责多个连接, 默认设置每个CPU核心一个线程.不要设置过大，如果过大，启动项目会报错：打开文件数过多server.undertow.io-threads=16\nworker-threads:阻塞任务线程池, 当执行类似servlet请求阻塞IO操作, undertow会从这个线程池中取得线程,它的值设置取决于系统线程执行任务的阻塞系数，默认值是IO线程数*8server.undertow.worker-threads=256\nbuffer-size:该配置会影响buffer,这些buffer会用于服务器连接的IO操作,有点类似netty的池化内存管理,每块buffer的空间大小,越小的空间被利用越充分，不要设置太大，以免影响其他应用，合适即可server.undertow.buffer-size=1024\nbuffers-per-region:每个区分配的buffer数量 , 所以pool的大小是buffer-size * buffers-per-regionserver.undertow.buffers-per-region=1024\ndirect-buffers:是否分配的直接内存(NIO直接分配的堆外内存)server.undertow.direct-buffers=true\n扩展文章SpringBoot服务器压测对比","thumbnail":"https://blogimg-1254014761.cos.ap-beijing.myqcloud.com/2020/04/12/qianbi.jpg","plink":"https://snailscoder.com/2020/04/11/architect/106/"},{"title":"高并发系统：池化技术-数据库连接池","date":"2020-04-11T22:49:25.000Z","date_formatted":{"ll":"2020年4月11日","L":"2020/04/11","MM-DD":"04-11"},"updated":"2020-04-12T03:16:58.028Z","content":"数据库连接池与系统线程池不同，数据库连接池并不控制应用端和数据库端的线程池的大小。而且每个数据库连接池的配置只是针对自己所在的应用服务进程，限制的是同一个进程内可以访问数据库的并行线程数目。\n数据库连接池好处节省了创建数据库连接的时间，通常这个时间大大超过处理数据访问请求的时间。统一管理数据库请求连接，避免了过多连接或频繁创建/删除连接带来的性能问题。监控了数据库连接的运行状态和错误报告，减少了应用服务的这部分代码。可以检查和报告不关闭数据库连接的错误，帮助运维监测数据库访问阻塞和帮助程序员写出正确数据库访问代码。连接池优化策略做为应用服务和数据库的桥梁，连接池参数配置的目标是全局优化。具体的优化目的有四个：\n尽可能满足应用服务的并发数据库访问所有需要访问数据库的线程都可以得到需要的数据库连接。如果一个线程用到多个连接，那么需要的连接数目也会成倍增加。这时，需要的连接池最大尺寸应该是最大的并发数据库访问线程数目乘以每个线程需要的连接数目。不让数据库服务器过载可能有多个应用服务器的多个连接池会同时发出请求。能发现用了不还造成的死锁应用程序错误会造成借了不还的情况，反复出现会造成连接池用完应用长期等待甚至死锁的状态。需要有连接借用的超时报错机制，而这个超时时间取决于具体应用。不浪费系统资源。配置过大的连接池会浪费应用服务器的系统资源，包括内存，网络端口，同步信号等。同时线程池的重启和操作都会响应变慢。不过应用端连接池的开销不是很大，资源的浪费通常不是太大问题。核心参数配置此处以Spring默认数据库连接池HikariCP为例：\nmaximum-pool-size:连接池中最大连接数（包括空闲和正在使用的连接）默认值是10，这个一般预估应用的最大连接数，后期根据监测得到一个最大值的一个平均值。要知道，最大连接并不是越多越好，一个connection会占用系统的带宽和存储。但是 当连接池没有空闲连接并且已经到达最大值，新来的连接池请求（HikariPool#getConnection）会被阻塞直到connectionTimeout（毫秒），超时后便抛出SQLException。minimum-idle:池中最小空闲连接数量。默认值10，小于池中最大连接数，一般根据系统大部分情况下的数据库连接情况取一个平均值。Hikari会尽可能、尽快地将空闲连接数维持在这个数量上。如果为了获得最佳性能和对峰值需求的响应能力，我们也不妨让他和最大连接数保持一致，使得HikariCP成为一个固定大小的数据库连接池。pool-name:连接池的名字。一般会出现在日志和JMX控制台中。默认值：auto-genenrated。建议取一个合适的名字，便于监控。auto-commit:是否自动提交池中返回的连接。默认值为true。一般是有必要自动提交上一个连接中的事务的。如果为false，那么就需要应用层手动提交事务。idle-timeout:空闲时间。仅在minimum-idle小于maximum-poop-size的时候才会起作用。默认值10分钟。根据应用实际情况做调整，对于一些间歇性流量达到峰值的应用，一般需要考虑设置的比间歇时间更大，防止创建数据库连接拖慢了应用速度。max-lifetime:连接池中连接的最大生命周期。当连接一致处于闲置状态时，数据库可能会主动断开连接。为了防止大量的同一时间处于空闲连接因为数据库方的闲置超时策略断开连接（可以理解为连接雪崩），一般将这个值设置的比数据库的“闲置超时时间”小几秒，以便这些连接断开后，HikariCP能迅速的创建新一轮的连接。connection-timeout:连接超时时间。默认值为30s，可以接收的最小超时时间为250ms。但是连接池请求也可以自定义超时时间（com.zaxxer.hikari.pool.HikariPool#getConnection(long)）。连接创建策略&lt;minimum-idle:如果当前连接数小于最小连接数，则创建新的连接处理数据库请求；如果连接池中有空闲连接则复用空闲连接；&gt;minimum-idle,&lt;maximum-pool-size:如果空闲池中没有连接并且当前连接数小于最大连接数，则创建新的连接处理请求；&gt;=maximum-pool-size:如果当前连接数已经大于等于最大连接数，则按照配置中设定的时间等待旧的连接可用；如果等待超过了这个设定时间则向用户抛出错误。\n参考文章数据库连接池设置HikariCP重要参数配置","thumbnail":"https://blogimg-1254014761.cos.ap-beijing.myqcloud.com/2020/04/12/mg6431.jpg","plink":"https://snailscoder.com/2020/04/11/architect/105/"},{"title":"高并发系统：池化技术-JDK线程池","date":"2020-04-11T22:39:25.000Z","date_formatted":{"ll":"2020年4月11日","L":"2020/04/11","MM-DD":"04-11"},"updated":"2020-04-12T03:17:10.055Z","content":"JDK 实现的这个线程池优先把任务放入队列暂存起来，而不是创建更多的线程，它比较适用于执行 CPU 密集型的任务，也就是需要执行大量 CPU 运算的任务。这是为什么呢？因为执行 CPU 密集型的任务时 CPU 比较繁忙，因此只需要创建和 CPU 核数相当的线程就好了，多了反而会造成线程上下文切换，降低任务执行效率。所以当前线程数超过核心线程数时，线程池不会增加线程，而是放在队列里等待核心线程空闲下来。\n一般核心线程数与CPU核数一致，计算公式：线程数目 = CPU核数 * CPU 利用率 * (1 + 等待时间 / CPU计算时间)\nJDK线程池核心参数12345678&#x2F;&#x2F;java.util.concurrent.ThreadPoolExecutorpublic ThreadPoolExecutor(int corePoolSize,                              int maximumPoolSize,                              long keepAliveTime,                              TimeUnit unit,                              BlockingQueue&lt;Runnable&gt; workQueue,                              ThreadFactory threadFactory,                              RejectedExecutionHandler handler)corePoolSize:线程池中的核心线程数,即使没有任务执行的时候,他们也是存在的.(不考虑配置了参数:allowCoreThreadTimeOut,allowCoreThreadTimeOut通过字面意思也能知道,就是是否允许核心线程超时,一般情况下不需要设置,本文不考虑)maximumPoolSize:线程池中的允许存在的最大线程数keepAliveTime:当线程池中的线程超过核心线程数的时候,这部分多余的空闲线程等待执行新任务的超时时间.例如:核心线程数为1 ,最大线程数为5,当前运行线程为4,keepAliveTime为60s,那么4-1=3个线程在空闲状态下等待60s 后还没有新任务到来,就会被销毁了.unit:keepAliveTime 的时间单位workQueue: 线程队列,如果当前时间核心线程都在运行,又来了一个新任务,那么这个新任务就会被放进这个线程队列中,等待执行.threadFactory: 线程池创建线程的工厂类.handler: 如果线程队列满了同事执行线程数也达到了maximumPoolSize,如果此时再来新的线程,将执行什么 handler 来处理这个线程. handler的默认提供的类型有:AbortPolicy: 抛出RejectedExecutionException异常DiscardPolicy: 什么都不做.DiscardOldestPolicy: 将线程队列中的最老的任务抛弃掉,换区一个空间执行当前的任务.CallerRunsPolicy: 使用当前的线程(比如 main)来执行这个线程.JDK线程创建回收策略&lt;corePoolSize:如果新加入一个运行的任务,当前运行的线程小于corePoolSize,这时候会在线程池中新建一个线程用于执行这个新的任务.&gt;corePoolSize,队列不满:如果新加入一个运行的任务,当前运行的线程大于等于corePoolSize,这个时候就需要将这个新的任务加入到线程队列workQueue中,一旦线程中的线程执行完成了一个任务,就会马上从队列中去一个任务来执行.&gt;corePoolSize,&lt;maximumPoolSize:如果队列也满了,怎么办呢? 如果maximumPoolSize大于corePoolSize,就会新建线程来处理这个新的任务,直到总运行线程数达到maximumPoolSize.&gt;maximumPoolSize:如果总运行线程数达到了maximumPoolSize,还来了新的任务怎么办呢?就需要执行上面所说的拒绝策略了handler了,按照配置的策略进行处理,默认不配置的情况下,使用的是AbortPolicy.keepAliveTime:超过corePoolSize的线程，在空闲时间超过keepAliveTime时会被释放allowCoreThreadTimeOut:在配置了allowCoreThreadTimeOut时，corePoolSize线程在空闲时也会释放，一般不配置。","thumbnail":"https://blogimg-1254014761.cos.ap-beijing.myqcloud.com/2020/04/12/pexelsphoto1040161.jpeg","plink":"https://snailscoder.com/2020/04/11/architect/104/"},{"title":"高并发系统：系统可用性的度量","date":"2020-04-11T19:39:25.000Z","date_formatted":{"ll":"2020年4月11日","L":"2020/04/11","MM-DD":"04-11"},"updated":"2020-04-12T03:03:30.519Z","content":"衡量指标可用性是一个抽象的概念，你需要知道要如何来度量它，与之相关的概念是：MTBF 和 MTTR。\nMTBF（Mean Time Between Failure） 是平均故障间隔的意思，代表两次故障的间隔时间，也就是系统正常运转的平均时间。这个时间越长，系统稳定性越高。\nMTTR（Mean Time To Repair）表示故障的平均恢复时间，也可以理解为平均故障时间。这个值越小，故障对于用户的影响越小。\n系统可用性指标： Availability = MTBF / (MTBF + MTTR)这个公式计算出的结果是一个比例，而这个比例代表着系统的可用性。一般来说，我们会使用几个九来描述系统的可用性。\n三个九之后，系统的年故障时间从 3 天锐减到 8 小时。四个九之后，年故障时间缩减到 1 小时之内。在这个级别的可用性下，你可能需要建立完善的运维值班体系、故障处理流程和业务变更流程。你可能还需要在系统设计上有更多的考虑。比如，在开发中你要考虑，如果发生故障，是否不用人工介入就能自动恢复。当然了，在工具建设方面，你也需要多加完善，以便快速排查故障原因，让系统快速恢复。五个九之后，故障就不能靠人力恢复了。想象一下，从故障发生到你接收报警，再到你打开电脑登录服务器处理问题，时间可能早就过了十分钟了。所以这个级别的可用性考察的是系统的容灾和自动恢复的能力，让机器来处理故障，才会让可用性指标提升一个档次。设计思路系统设计failover（故障转移）心跳监测，故障转移超时控制通过收集系统之间的调用日志，统计比如说 99% 的响应时间是怎样的，然后依据这个时间来指定超时时间降级降级是为了保证核心服务的稳定而牺牲非核心服务的做法。限流通过对并发的请求进行限速来保护系统系统运维灰度发布灰度发布指的是系统的变更不是一次性地推到线上的，而是按照一定比例逐步推进的。故障演练故障演练指的是对系统进行一些破坏性的手段，观察在出现局部故障时，整体的系统表现是怎样的，从而发现系统中存在的，潜在的可用性问题。","thumbnail":"https://blogimg-1254014761.cos.ap-beijing.myqcloud.com/2020/04/12/1.png","plink":"https://snailscoder.com/2020/04/11/architect/103/"},{"title":"高并发系统：经典分层举例","date":"2020-04-11T17:39:25.000Z","date_formatted":{"ll":"2020年4月11日","L":"2020/04/11","MM-DD":"04-11"},"updated":"2020-04-12T03:03:30.526Z","content":"1.应用三层架构\n表现层：顾名思义嘛，就是展示数据结果和接受用户指令的，是最靠近用户的一层；逻辑层：里面有复杂业务的具体实现；数据访问层则：是主要处理和存储之间的交互。\n2.网络分层架构\nOSI 网络模型，它把整个网络分成了七层，自下而上分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。TCP/IP 协议，它把网络简化成了四层，即链路层、网络层、传输层和应用层。每一层各司其职又互相帮助，网络层负责端到端的寻址和建立连接，传输层负责端到端的数据传输等，同时相邻两层还会有数据的交互。这样可以隔离关注点，让不同的层专注做不同的事情。\n3.Linux文件系统分层\n在文件系统的最上层是虚拟文件系统（VFS），用来屏蔽不同的文件系统之间的差异，提供统一的系统调用接口。虚拟文件系统的下层是 Ext3、Ext4 等各种文件系统，再向下是为了屏蔽不同硬件设备的实现细节，我们抽象出来的单独的一层——通用块设备层，然后就是不同类型的磁盘了。\n\n4.阿里系统分层规约\n终端显示层：各端模板渲染并执行显示的层。当前主要是 Velocity 渲染，JS 渲染， JSP 渲染，移动端展示等。开放接口层：将 Service 层方法封装成开放接口，同时进行网关安全控制和流量控制等。Web 层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。Service 层：业务逻辑层。Manager 层：通用业务处理层。这一层主要有两个作用，其一，你可以将原先 Service 层的一些通用能力下沉到这一层，比如与缓存和存储交互策略，中间件的接入；其二，你也可以在这一层封装对第三方接口的调用，比如调用支付服务，调用审核服务等。DAO 层：数据访问层，与底层 MySQL、Oracle、HBase 等进行数据交互。外部接口或第三方平台：包括其它部门 RPC 开放接口，基础平台，其它公司的 HTTP 接口。","thumbnail":"https://blogimg-1254014761.cos.ap-beijing.myqcloud.com/2020/04/12/haibian.jpg","plink":"https://snailscoder.com/2020/04/11/architect/102/"},{"title":"高并发系统：通用设计方法","date":"2020-04-11T16:56:25.000Z","date_formatted":{"ll":"2020年4月11日","L":"2020/04/11","MM-DD":"04-11"},"updated":"2020-04-12T02:51:20.404Z","content":"洪水猛兽通常如何治理洪水，方案如下：\n分流：将水分流到多个支流中，以分担水流压力提高流速： 拓宽河道，清除淤沙让流水更加顺畅水库：将水引入水库先存储起来，然后再想办法把水库中的水缓缓地排出去，以此提高下游的抗洪能力高并发高并发就像洪水猛兽，处理方案类似：\n横向扩展：分而治之是一种常见的高并发系统设计方法，采用分布式部署的方式把流量分流开，让每个服务器都承担一部分并发和流量。缓存：使用缓存来提高系统的性能，就好比用“拓宽河道”的方式抵抗高并发大流量的冲击。异步：在某些场景下，未处理完成之前我们可以让请求先返回，在数据准备好之后再通知请求方，这样可以在单位时间内处理更多的请求。\n方案一：Scale-out（横向扩展）系统分布式设计，横向扩展，增加节点。微服务：SpringCloud\n方案二：缓存为什么使用缓存？普通磁盘的寻道时间是 10ms 左右，而相比于磁盘寻道花费的时间，CPU 执行指令和内存寻址的时间都是在 ns（纳秒）级别，从千兆网卡上读取数据的时间是在μs（微秒）级别。所以在整个计算机体系中磁盘是最慢的一环，甚至比其它的组件要慢几个数量级。因此我们通常使用以内存作为存储介质的缓存，以此提升性能。Redis\n方案三：异步调用方不需要等待方法逻辑执行完成就可以返回执行其他的逻辑，在被调用方法执行完毕后再通过回调、事件通知等方式将结果反馈给调用方。Reactive三方消息：RabbitMQ，Kafka，RocketMQ，ActiveMQ等\n","thumbnail":"https://blogimg-1254014761.cos.ap-beijing.myqcloud.com/2020/04/01/img1276.png","plink":"https://snailscoder.com/2020/04/11/architect/101/"},{"title":"学会承受人生必然的孤独，过了才能看见美好繁华！","date":"2020-04-03T16:38:25.000Z","date_formatted":{"ll":"2020年4月3日","L":"2020/04/03","MM-DD":"04-03"},"updated":"2020-04-12T04:23:27.157Z","content":"人生语录：学会承受人生必然的孤独，过了才能看见美好繁华！\n分享一段特别好的话：“爱好，是可以救命的”，当你人生迷茫困惑的时候，不要停下来，去做你喜欢的事情，忙碌起来，改变心境，你会逐渐发现，一切居然豁然开朗起来…生活中有很多不容易，却阻挡不了任何一个热爱生活的人去散发光芒。\n身边朋友纵然很多，但如若没有合拍的，在一起时内心想必也是孤独的。不合无意义的群。孤独虽然如影随形，但不必惧怕它，它是你生活中不可或缺的一部分，试着与它相处吧。孤独不是贬义词，当一个人的时候，可以思考自己的事情，欣赏喜欢的电影。或者培养一个爱好吧，也许在喜欢的领域里会交到更合拍的朋友。耐得住寂寞，才能享的了长远。\n真正想要的东西，不只是踮踮脚尖那么简单，所有的收获，一定要全力以赴，奋不顾身。 人生没有多走的路，脚下的每一步都算数。没有不请自来的幸运，只有有备而来的惊艳。没有人能定义你的未来，除了你自己。\n","thumbnail":"https://blogimg-1254014761.cos.ap-beijing.myqcloud.com/2020/04/12/gudu.png","plink":"https://snailscoder.com/2020/04/03/notes/2020-04-03/"},{"title":"东小口森林公园-花朵","date":"2020-04-02T17:51:00.000Z","date_formatted":{"ll":"2020年4月2日","L":"2020/04/02","MM-DD":"04-02"},"updated":"2020-04-12T04:16:36.817Z","content":"裁剪前\n裁剪后\n自行车，拍的很不好看。水平欠佳\n","thumbnail":"https://blogimg-1254014761.cos.ap-beijing.myqcloud.com/2020/04/01/dsc0346.jpg","plink":"https://snailscoder.com/2020/04/02/travel/dxk/"},{"title":"个人博客Nginx强制跳转Https配置","date":"2020-04-01T19:38:25.000Z","date_formatted":{"ll":"2020年4月1日","L":"2020/04/01","MM-DD":"04-01"},"updated":"2020-04-01T12:25:46.588Z","content":"今日因需要将自己的博客域名加入https支持，并把之前的HTTP访问强制跳转到HTTPS。\n1、nginx支持https如果起初nginx编译时没有添加ssl支持，需要对nginx重新编译，增加http_ssl_module模块\n12345671.配置.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --with-http_stub_status_module --with-http_ssl_module2.编译安装make &amp;&amp; make install2、配置https域及SSL证书没有证书的可以考虑腾讯云申请免费证书，但仅限单域名,申请地址:https://cloud.tencent.com/product/ssl,申请通过后，下载nginx专用证书。以下为https证书相关配置\n123456789101112server &#123;    listen       443 ssl;    server_name  www.snailscoder.com;    ssl_certificate      ..&#x2F;ssl&#x2F;***.crt;    ssl_certificate_key  ..&#x2F;ssl&#x2F;***.key;    ssl_session_cache    shared:SSL:1m;    ssl_session_timeout  5m;    location &#x2F; &#123;        root   html;        index  index.html index.htm;    &#125;&#125;配置好后，测试https是否可以正常访问。\n3、http强制跳转https此处因http下无其他信息，单纯配置了跳转\n12345678910server &#123;    listen       80;    server_name  www.snailscoder.com;    #方式一    return      301 https:&#x2F;&#x2F;$server_name$request_uri;    #方式二    #rewrite ^&#x2F;(.*)$ https:&#x2F;&#x2F;www.snailscoder.com&#x2F;$1 permanent;    #方式三    #rewrite ^ https:&#x2F;&#x2F;www.snailscoder.com$request_uri? permanent;&#125;博客内容较简单，仅为个人配置记录，有问题可留言咨询。有更好的方案，也请多多指教。\n","thumbnail":"https://blogimg-1254014761.cos.ap-beijing.myqcloud.com/2020/04/01/img1276.png","plink":"https://snailscoder.com/2020/04/01/http/nginx-rewrite/"},{"title":"Java虚拟机总结思维导图","date":"2020-04-01T19:38:25.000Z","date_formatted":{"ll":"2020年4月1日","L":"2020/04/01","MM-DD":"04-01"},"updated":"2020-04-01T12:24:41.066Z","content":"\n","thumbnail":"https://blogimg-1254014761.cos.ap-beijing.myqcloud.com/2020/04/01/wnlpc.png","plink":"https://snailscoder.com/2020/04/01/java/100001/"},{"title":"闲逛景山","date":"2020-03-31T21:51:00.000Z","date_formatted":{"ll":"2020年3月31日","L":"2020/03/31","MM-DD":"03-31"},"updated":"2020-04-12T04:16:36.854Z","content":"盛开的梅花\n远望故宫博物院\n园中肥野猫\n寂静的街头\n","thumbnail":"https://blogimg-1254014761.cos.ap-beijing.myqcloud.com/2020/03/31/dsc0562.jpg","plink":"https://snailscoder.com/2020/03/31/travel/jingshan/"},{"title":"Java中flag和flag==true的区别","date":"2020-03-21T21:56:25.000Z","date_formatted":{"ll":"2020年3月21日","L":"2020/03/21","MM-DD":"03-21"},"updated":"2020-04-01T12:24:46.477Z","content":"有如下 Test.java 文件\n123456789public class Test &#123;     public static void main(String[] args) &#123;          boolean flag &#x3D; true;          if (flag)             System.out.println(&quot;Hello, Java!&quot;);          if (flag &#x3D;&#x3D; true)                   System.out.println(&quot;Hello, JVM!&quot;);     &#125;&#125;此处 flag和flag == true大家认为有区别吗？\n下边让我们来见证一下奇迹:\njavac Foo.java 命令生成 Foo.class 文件，使用 JD-GUI 打开内容如下：\n123456789101112131415import java.io.PrintStream;public class Foo&#123;  public static void main(String[] paramArrayOfString)  &#123;    int i &#x3D; 1;    if (i !&#x3D; 0) &#123;      System.out.println(&quot;Hello, Java!&quot;);    &#125;    if (i &#x3D;&#x3D; 1) &#123;      System.out.println(&quot;Hello, JVM!&quot;);    &#125;  &#125;&#125;大家看到不同之处了吗？\n","thumbnail":"https://blogimg-1254014761.cos.ap-beijing.myqcloud.com/2020/03/21/9a15a3bb8de2b97650bf14ff310e39ac.jpg","plink":"https://snailscoder.com/2020/03/21/java/100000/"},{"title":"北海公园之游","date":"2020-03-21T11:56:25.000Z","date_formatted":{"ll":"2020年3月21日","L":"2020/03/21","MM-DD":"03-21"},"updated":"2020-04-12T04:16:36.845Z","content":"\n\n\n\n\n","thumbnail":"https://blogimg-1254014761.cos.ap-beijing.myqcloud.com/2020/03/31/bh20200320.jpg","plink":"https://snailscoder.com/2020/03/21/travel/beihai/"},{"title":"一条SQL查询语句是如何执行的","date":"2020-03-20T21:56:25.000Z","date_formatted":{"ll":"2020年3月20日","L":"2020/03/20","MM-DD":"03-20"},"updated":"2020-04-12T03:17:36.932Z","content":"\nMySQL 的逻辑架构图\n连接器查询缓存分析器优化器执行器","thumbnail":"https://blogimg-1254014761.cos.ap-beijing.myqcloud.com/2020/03/31/38dd4b12f16d2f9667fb169be0f0698b.jpg","plink":"https://snailscoder.com/2020/03/20/mysql/select-run/"},{"title":"疫情下的颐和园","date":"2020-03-20T10:56:25.000Z","date_formatted":{"ll":"2020年3月20日","L":"2020/03/20","MM-DD":"03-20"},"updated":"2020-04-12T04:16:35.273Z","content":"疫情期间的颐和园，人烟稀少，却是风光无限，沉淀出了时光的痕迹。择一日，春光曼妙，风和日丽，漫步园中，岁月静好。\n园内风景十七孔桥\n远观玉峰塔\n清净的湖面，风景美不胜收\n盛开的山桃花\n远眺佛香阁\n再现十七孔桥\n零星的观景人\n昔日吵闹的长廊\n阳春三月，昔日人流如织，如今….\n没有游船，只有野鸭、黑天鹅;没有商店，没有泡面、火腿;\n人烟稀少，却是风光无限。\n希望疫情早点结束…\n入园攻略提前一天“颐和园”官方微信公众号进行预约购票，可预约上午、下午两个时段，不预约不能进。第二天直接刷身份证入园（一定要带身份证！！）疫情期间只有新建宫门开放，其他都是关闭的。开车前往的旁边有6-7号停车场，方便停车。","thumbnail":"https://blogimg-1254014761.cos.ap-beijing.myqcloud.com/2020/03/20/shi-qi-kong-qiao.jpg","plink":"https://snailscoder.com/2020/03/20/travel/yhy/"},{"title":"关于’蜗码‘","date":"2020-04-12T12:32:22.880Z","date_formatted":{"ll":"2020年4月12日","L":"2020/04/12","MM-DD":"04-12"},"updated":"2020-04-02T03:31:31.343Z","content":"博客来由我们每个人的在网络上产生的数据越来越多，这些信息是我们在互联网上存在过的痕迹，值得我们认真对待。但是它们被分散分布在各个网站上。很多时候我们很难将它们聚合在一起，而且各个网站的信息排布方式也没有办法自由控制，所以我们需要一个可以由自己主宰的空间——博客。\n通过博客，我们可以记录自己的生活和成长的轨迹。它不像 Twitter 那样碎片化，也不像 Facebook 那样关系化，它是私人的空间。\n关于’蜗码‘蜗牛，一步一个脚印的向自己的目标爬行.蜗码，像蜗牛一样的码农，让自己像蜗牛一样，踏踏实实的进步，不再浮躁。\n博客平台博客： Hexo部署： GitHub Pages主题： inside评论： Gitalk\n","plink":"https://snailscoder.com/about/"}]